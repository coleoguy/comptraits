res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
beta1s <- seq(from=7,to=10, length.out=100)
beta2s <- seq(from=0.5,to=2, length.out=100)
#mu1s <- seq(from=2,to=6, length.out=100)
#mu2s <- seq(from=10,to=35, length.out=100)
infarchs <- as.data.frame(matrix(NA, 100, 1))
for(i in 1:100){
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
plot(res)
#dat[[2]]
#dat[[3]]
infarchs[i,1] <- paste(res$varimp[,1][res$estimates[1,2:ncol(res$estimates)] > res$estimates[2,2:ncol(res$estimates)] & res$varimp[,2] > 0.5], collapse=",")
}
beta1s <- seq(from=7,to=10, length.out=100)
beta2s <- seq(from=0.5,to=2, length.out=100)
#mu1s <- seq(from=2,to=6, length.out=100)
#mu2s <- seq(from=10,to=35, length.out=100)
infarchs <- as.data.frame(matrix(NA, 100, 1))
for(i in 1:100){
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
#plot(res)
#dat[[2]]
#dat[[3]]
infarchs[i,1] <- paste(res$varimp[,1][res$estimates[1,2:ncol(res$estimates)] > res$estimates[2,2:ncol(res$estimates)] & res$varimp[,2] > 0.5], collapse=",")
}
View(infarchs)
makedat <- function(arch1, arch2, mu1, mu2, beta1, beta2, deffc){
cmat <- matrix(c(1,	0,	1,	0,	0,
0.5,	0.5,	0.25,	0.25,	0.25,
0,	1,	0,	0,	1,
-0.5,	0.5,	0.25,	-0.25,	0.25,
-1,	0,	1,	0,	0),5,5, byrow = T)
row.names(cmat) <- c("P1","BC1","F1","BC2","P2")
colnames(cmat) <- c("a","d","aa","ad","dd")
t1 <- rnorm(mean = mu1 + beta1 * cmat[,colnames(cmat) == arch1],
sd = .05 * (mu1 + abs(beta1)),
n = 5)
t2 <- rnorm(mean = mu2 + beta2 * cmat[,colnames(cmat) == arch2],
sd = .05 * (mu2 + abs(beta2)),
n = 5)
if(deffc == "prod") c1 <- t1 * t2
if(deffc == "diff") c1 <- t1 - t2
if(deffc == "ratio") c1 <- t1 / t2
if(deffc == "sum") c1 <- t1 + t2
dat <- as.data.frame(matrix(NA, 5,7))
colnames(dat) <- c("cross",	"mean",	"SE",	"sex",	"environ",	"sire",	"dam")
dat$cross <- c("P1","BC1","F1","BC2","P2")
dat$mean <- c1
dat$SE <- .1 * c1
dat$sex <- rep("U", 5)
dat$environ <- rep(1, 5)
dat$sire <- c(1,3,1,3,5)
dat$dam <- c(1,1,5,5,5)
res <- list(dat, t1,t2)
return(res)
}
beta1s <- seq(from=0.5,to=2, length.out=100)
beta2s <- seq(from=7,to=10, length.out=100)
#mu1s <- seq(from=2,to=6, length.out=100)
#mu2s <- seq(from=10,to=35, length.out=100)
infarchs <- as.data.frame(matrix(NA, 100, 1))
for(i in 1:100){
dat <- makedat(arch1 = "a", arch2 = "d", mu1 = 3, mu2 = 30,
beta2 = beta1s[i], beta1 = beta2s[i], deffc = "prod")
res <- LCA(data = dat[[1]], SCS = "NSC", keep.pars=c("Aa","Ad","AaAa","AaAd","AdAd"))
#plot(res)
#dat[[2]]
#dat[[3]]
infarchs[i,1] <- paste(res$varimp[,1][res$estimates[1,2:ncol(res$estimates)] > res$estimates[2,2:ncol(res$estimates)] & res$varimp[,2] > 0.5], collapse=",")
}
View(infarchs)
setwd("~/Desktop/Repositories/comptraits/scripts")
#read in this file for 15 cohort set
dat <- read.csv("../results/additional.cohorts.results/15cohorts/jd.sim.results-simplified-archs.csv")
min(dat$beta)
min(dat$beta, na.rm=T)
min(dat$beta, na.rm=T, head=10)
# remove from original sim results file - 15 cohorts
df <- read_csv("../results/additional.cohorts.results/15cohorts/jd.sim.results-simplified-archs.csv")
# filter rows where "beta" is non-NA and less than 0.002
filtered_rows <- which(!is.na(df$beta) & df$beta < 0.002)
# remove sections of 8 rows when elemental trait is less than 0.002
df <- df[-c(c(1353:1360, 2481:2488, 3921:3928, 4457:4464, 4577:4584, 8673:8680,
10225:10232, 30121:30128, 32265:32272, 34257:34264)), ]
# remove from original sim results file - 15 cohorts
df <- read_csv("../results/additional.cohorts.results/15cohorts/jd.sim.results-simplified-archs.csv")
# filter rows where "beta" is non-NA and less than 0.002
filtered_rows <- which(!is.na(df$beta) & df$beta < 0.002)
# remove sections of 8 rows when elemental trait is less than 0.002
df <- df[-c(c(1353:1360, 2481:2488, 3921:3928, 4457:4464, 4577:4584, 8673:8680,
10225:10232, 30121:30128, 32265:32272, 34257:34264)), ]
write.csv(df, "../results/additional.cohorts.results/jd_15coh_rm_sm_betas_res.csv", row.names = F)
setwd("~/Desktop/Repositories/comptraits/scripts")
setwd("~/Desktop/Repositories/comptraits/scripts/additional.cohort.analyses/jd.cohort15")
# read in the data
dat <- read.csv("../../../results/additional.cohorts.results/15cohorts/jd_15coh_rm_sm_betas_res.csv")
# grab the rows that each dataset starts on
starts <- seq(from=1, by=8, length.out=5991)
# container for adding up successes
succ.matrix <- as.data.frame(matrix(0, nrow = 18, ncol = 9))
succ.matrix[, 1] <- c("a", "a", "d", "a", "a", "a", "d", "d", "d", "aa", "aa", "aa", "ad", "ad", "ad", "dd", "dd", "dd")
succ.matrix[, 2] <- c("a", "d", "d", "aa", "ad", "dd", "aa", "ad", "dd", "aa", "ad", "dd", "aa", "ad", "dd", "aa", "ad", "dd")
colnames(succ.matrix) <- c("first element", "second element", "1/2", "2/1", "1*2", "1+2", "1-2", "2-1", "total")
for(i in 1:(length(starts)-1)){
# get the current dataset to evaluate
foo <- dat[starts[i]:(starts[i+1]-1),]
# find columns that correspond to elemental architecture
# the hard coding on pulling it out of foo is correct as this never changes
arch1 <- which(colnames(foo) == foo[1,1])
arch2 <- which(colnames(foo) == foo[2,1])
# check each row of the current dataset where each row corresponds to
# a generating function. We want to count any row as a success only if
# it has the underlying elemental architecture and nothing eles
for(j in 3:8){
a <- !is.na(foo[j,arch1])
b <- !is.na(foo[j,arch2])
falarchs <- (3:7)[!3:7 %in% c(arch1,arch2)]
c <- is.na(foo[j, falarchs])
x <- succ.matrix$`first element` == foo[1,1]
y <- succ.matrix$`second element` == foo[2,1]
targ.row <- which(x+y == 2)
if(all(c(a,b,c))){
print("success")
# get the row to enter into
succ.matrix[targ.row, j] <- succ.matrix[targ.row, j] + 1
succ.matrix[targ.row, 9] <- succ.matrix[targ.row, 9] +1
}else{
print("failed")
succ.matrix[targ.row, 9] <- succ.matrix[targ.row, 9] +1
}
}
}
succ.matrix[,3:8] <- round(succ.matrix[,3:8] / (succ.matrix$total/6), digits=2)
View(succ.matrix)
write.csv(jd.succ.matrix, "../../../results/additional.cohorts.results/jd.cohorts15/jd.succ.matrix.csv", row.names = F)
write.csv(succ.matrix, "../../../results/additional.cohorts.results/jd.cohorts15/jd.succ.matrix.csv", row.names = F)
write.csv(succ.matrix, "../../../results/additional.cohorts.results/15cohorts/jd.succ.matrix.csv", row.names = F)
# read in the data
dat <- read.csv("../../../results/additional.cohorts.results/15cohorts/jd_15coh_rm_sm_betas_res.csv")
# grab the rows that each dataset starts on
starts <- seq(from=1, by=8, length.out=5991)
# container for adding up successes
part.matrix <- as.data.frame(matrix(0, nrow = 18, ncol = 9))
part.matrix[, 1] <- c("a", "a", "d", "a", "a", "a", "d", "d", "d", "aa", "aa", "aa", "ad", "ad", "ad", "dd", "dd", "dd")
part.matrix[, 2] <- c("a", "d", "d", "aa", "ad", "dd", "aa", "ad", "dd", "aa", "ad", "dd", "aa", "ad", "dd", "aa", "ad", "dd")
colnames(part.matrix) <- c("first element", "second element", "1/2", "2/1", "1*2", "1+2", "1-2", "2-1", "total")
for(i in 1:(length(starts)-1)){
# get the current dataset to evaluate
foo <- dat[starts[i]:(starts[i+1]-1),]
# find columns that correspond to elemental architecture
# the hard coding on pulling it out of foo is correct as this never changes
arch1 <- which(colnames(foo) == foo[1,1])
arch2 <- which(colnames(foo) == foo[2,1])
# check each row of the current dataset where each row corresponds to
# a generating function. We want to count any row as a partial if
# it has the underlying elemental architecture AND other architures as well
for(j in 3:8){
a <- !is.na(foo[j,arch1])
b <- !is.na(foo[j,arch2])
#falarchs <- (3:7)[!3:7 %in% c(arch1,arch2)]
#c <- is.na(foo[j, falarchs])
x <- part.matrix$`first element` == foo[1,1]
y <- part.matrix$`second element` == foo[2,1]
targ.row <- which(x+y == 2)
if(all(c(a,b))){
print("success")
# get the row to enter into
part.matrix[targ.row, j] <- part.matrix[targ.row, j] + 1
part.matrix[targ.row, 9] <- part.matrix[targ.row, 9] +1
}else{
print("failed")
part.matrix[targ.row, 9] <- part.matrix[targ.row, 9] +1
}
}
}
part.matrix[,3:8] <- round(part.matrix[,3:8] / (part.matrix$total/6), digits=2)
#you can save the partial matrix at this step. it is the full version containing all
#pairs of elemental traits AND all 6 defining function. proceed to the next lines of
#code if you want to condense the partial matrix
write.csv(part.matrix, "../../../results/additional.cohorts.results/15cohorts/jd.part.matrix.csv", row.names = F)
part.matrix_mean <- part.matrix[1:3, 1:8]
####combining a&aa, a&ad, a&dd
means <- colMeans(part.matrix[4:6, 3:8], na.rm = TRUE)
# Create a new row with "a" in column 1, "e" in column 2, and the calculated means in columns 3-8
new_row <- c("a", "e", as.numeric(means), NA)
# Convert the new row to a dataframe
new_row_df <- as.data.frame(t(new_row), stringsAsFactors = FALSE)
names(new_row_df) <- names(part.matrix)
# Bind the new row to the dataframe
part.matrix_mean <- rbind(part.matrix[1:3, ], new_row_df)
####combining d&aa, d&ad, d&dd
means <- colMeans(part.matrix[7:9, 3:8], na.rm = TRUE)
# Create a new row with "d" in column 1, "e" in column 2, and the calculated means in columns 3-8
new_row <- c("d", "e", as.numeric(means), NA)
# Convert the new row to a dataframe
new_row_df <- as.data.frame(t(new_row), stringsAsFactors = FALSE)
names(new_row_df) <- names(part.matrix)
# Bind the new row to the dataframe
part.matrix_mean <- rbind(part.matrix_mean[1:4, ], new_row_df)
####combining aa&aa, aa&ad, aa&dd, ad&aa, ad&ad, ad&dd, dd&aa, dd&ad, dd&dd
means <- colMeans(part.matrix[10:18, 3:8], na.rm = TRUE)
# Create a new row with "e" in column 1, "e" in column 2, and the calculated means in columns 3-8
new_row <- c("e", "e", as.numeric(means), NA)
# Convert the new row to a dataframe
new_row_df <- as.data.frame(t(new_row), stringsAsFactors = FALSE)
names(new_row_df) <- names(part.matrix)
# Bind the new row to the dataframe
part.matrix_mean <- rbind(part.matrix_mean[1:5, ], new_row_df)
#make sure that division columns are numeric before proceeding
part.matrix_mean[, 3] <- as.numeric(part.matrix_mean[, 3])
part.matrix_mean[, 4] <- as.numeric(part.matrix_mean[, 4])
#condensed 1/2 and 2/1 into a single column using mean
part.matrix_mean$division <- rowMeans(part.matrix_mean[, 3:4], na.rm = TRUE)
#reordered cols and removed extra subtraction (which was identical to other subtraction) and totals col
part.matrix_mean <- part.matrix_mean[,c(1:2, 6:7, 5, 10)]
#condensed col names
colnames(part.matrix_mean) <- c("first element", "second element", "addition", "subtraction", "multiplication", "division")
#here you can save the condensed partial matrix
write.csv(part.matrix_mean, "../../../results/additional.cohorts.results/15cohorts/jd_partial_matrix_means.csv", row.names = F)
# read in the data
dat <- read.csv("../../../results/additional.cohorts.results/15cohorts/jd_15coh_rm_sm_betas_res.csv")
# grab the rows that each dataset starts on
starts <- seq(from=1, by=8, length.out=5991)
# container for adding up failesses
fail.matrix <- as.data.frame(matrix(0, nrow = 18, ncol = 9))
fail.matrix[, 1] <- c("a", "a", "d", "a", "a", "a", "d", "d", "d", "aa", "aa", "aa", "ad", "ad", "ad", "dd", "dd", "dd")
fail.matrix[, 2] <- c("a", "d", "d", "aa", "ad", "dd", "aa", "ad", "dd", "aa", "ad", "dd", "aa", "ad", "dd", "aa", "ad", "dd")
colnames(fail.matrix) <- c("first element", "second element", "1/2", "2/1", "1*2", "1+2", "1-2", "2-1", "total")
for(i in 1:(length(starts)-1)){
# get the current dataset to evaluate
foo <- dat[starts[i]:(starts[i+1]-1),]
# find columns that correspond to elemental architecture
# the hard coding on pulling it out of foo is correct as this never changes
arch1 <- which(colnames(foo) == foo[1,1])
arch2 <- which(colnames(foo) == foo[2,1])
# check each row of the current dataset where each row corresponds to
# a generating function. We want to count any row as a failess only if
# it has the underlying elemental architecture and nothing eles
for(j in 3:8){
a <- is.na(foo[j,arch1])
b <- is.na(foo[j,arch2])
#falarchs <- (3:7)[!3:7 %in% c(arch1,arch2)]
#c <- is.na(foo[j, falarchs])
x <- fail.matrix$`first element` == foo[1,1]
y <- fail.matrix$`second element` == foo[2,1]
targ.row <- which(x+y == 2)
if(a | b){
print("success")
# get the row to enter into
fail.matrix[targ.row, j] <- fail.matrix[targ.row, j] + 1
fail.matrix[targ.row, 9] <- fail.matrix[targ.row, 9] +1
}else{
print("failed")
fail.matrix[targ.row, 9] <- fail.matrix[targ.row, 9] +1
}
}
}
fail.matrix[,3:8] <- round(fail.matrix[,3:8] / (fail.matrix$total/6), digits=2)
write.csv(jd.fail.matrix, "../../../results/additional.cohorts.results/jd.cohorts15/jd.fail.matrix.csv", row.names = F)
write.csv(fail.matrix, "../../../results/additional.cohorts.results/jd.cohorts15/jd.fail.matrix.csv", row.names = F)
write.csv(fail.matrix, "../../../results/additional.cohorts.results/15cohorts/jd.fail.matrix.csv", row.names = F)
setwd("~/Desktop/Repositories/comptraits/scripts")
# read in partial matrix (condensed version) for 5 cohort set
small <- read.csv("../results/partial.matrix_mean.csv")
View(small)
# Load necessary library
library(tidyr)
small <- as.matrix(read.csv("../results/partial.matrix_mean.csv", header = TRUE, row.names = c(1,2)))
small <- as.matrix(read.csv("../results/partial.matrix_mean.csv", header = TRUE, row.names = 1)
small <- as.matrix(read.csv("../results/partial.matrix_mean.csv", header = TRUE, row.names = 1))
small <- as.matrix(read.csv("../results/partial.matrix_mean.csv", header = TRUE, row.names = F))
small <- as.matrix(read.csv("../results/partial.matrix_mean.csv", header = TRUE))
View(small)
large <- as.matrix(read.csv("../results/additional.cohorts.results/15cohorts/jd_partial_matrix_means.csv", header = TRUE))
# Check if the matrices have the same dimensions
if(!all(dim(matrix_a) == dim(matrix_b))) {
stop("The matrices do not have the same dimensions.")
}
# Check if the matrices have the same dimensions
if(!all(dim(small) == dim(large))) {
stop("The matrices do not have the same dimensions.")
}
# Flatten the matrices into vectors
vector_small <- as.vector(small[,3:8])
# read in partial matrix (condensed version) for 5 cohort set
small <- read.csv("../results/partial.matrix_mean.csv")
# read in partial matrix (condensed version) for 15 cohort set
large <- read.csv("../results/additional.cohorts.results/15cohorts/jd_partial_matrix_means.csv")
small_numeric <- small[,3:8]
small_numeric <- small(small[,3:8])
small_numeric <- as.matrix(small[,3:8])
View(small)
small_numeric <- as.matrix(small[,3:6])
large_numeric <- as.matrix(small[,3:6])
# Check if the matrices have the same dimensions
if(!all(dim(small_numeric) == dim(large_numeric))) {
stop("The matrices do not have the same dimensions.")
}
# Flatten the matrices into vectors
small_vector <- as.vector(small_numeric)
large_vector <- as.vector(large_numeric)
t.test(small_vector, large_vector, paired = TRUE)
View(large)
View(small)
t.test(small_numeric, large_numeric, paired = TRUE)
# Load necessary library
library(tidyr)
# read in partial matrix (condensed version) for 5 cohort set
small <- read.csv("../results/partial.matrix_mean.csv")
# read in partial matrix (condensed version) for 15 cohort set
large <- read.csv("../results/additional.cohorts.results/15cohorts/jd_partial_matrix_means.csv")
small_numeric <- as.matrix(small[,3:6])
large_numeric <- as.matrix(large[,3:6])
# Check if the matrices have the same dimensions
if(!all(dim(small_numeric) == dim(large_numeric))) {
stop("The matrices do not have the same dimensions.")
}
# Flatten the matrices into vectors
small_vector <- as.vector(small_numeric)
large_vector <- as.vector(large_numeric)
t.test(small_vector, large_vector, paired = TRUE)
# SMALL COHORT SET - 5 cohorts - DEFINING FUNCTIONS
addition_small <- mean(small$addition) #0.55
subtraction_small <- mean(small$subtraction) #0.5
multiplication_small <- mean(small$multiplication) #0.67
division_small <- mean(small$division) #0.41
# LARGE COHORT SET - 15 cohorts - DEFINING FUNCTIONS
addition_large <- mean(large$addition) #0.55
subtraction_large <- mean(large$subtraction)
multiplication_large <- mean(large$multiplication) #
division_large <- mean(large$division) #0.41
# SMALL COHORT SET - 5 cohorts - ELEM ARCHS
aa <- as.matrix(small[1,2:5])
# read in partial matrix (condensed version) for 5 cohort set
small <- read.csv("../results/partial.matrix_mean.csv")
# read in partial matrix (condensed version) for 15 cohort set
large <- read.csv("../results/additional.cohorts.results/15cohorts/jd_partial_matrix_means.csv")
# SMALL COHORT SET - 5 cohorts - ELEM ARCHS
aa <- as.matrix(small[1,2:5])
aa_meansmall <- mean(aa) #0.94
View(small)
# SMALL COHORT SET - 5 cohorts - ELEM ARCHS
aa <- as.matrix(small[1,3:6])
aa_meansmall <- mean(aa) #0.94
ad <- as.matrix(small[2,3:6])
ad_meansmall <- mean(ad) #0.395
dd <- as.matrix(small[3,3:6])
dd_meansmall <- mean(dd) #0.74
#Read in succ.matrix.csv
dat <- read.csv("../results/partial.matrix_mean.csv")
#make function cols numeric and round to 2 decimal places
for (i in 3:6) {
dat[, i] <- round(as.numeric(dat[, i]), 2)
}
#combine columns 1 & 2
combined_column <- paste(dat$"first.element", dat$"second.element", sep = " & ")
# Name the combined column
dat$'Elemental.Architectures' <- combined_column
#remove the 1st & 2nd column (first element & second element cols)
dat <- dat[, -c(1,2)]
#rearrange to make elemental architectures column 1
dat <- dat[, c(5, 1:4)]
# Melt the table to long format
dat.long <- melt(dat, id.vars = "Elemental.Architectures")
# Reorder the levels of Elemental.Architectures based on the original order
dat.long$Elemental.Architectures <- factor(dat.long$Elemental.Architectures, levels = unique(dat$Elemental.Architectures))
# Create the plot
ggplot(dat.long, aes(variable, Elemental.Architectures, fill = value)) +
geom_tile() +
geom_text(aes(label = value), color = "white", size = 5.5) + #added numbers to cells#
scale_fill_viridis(name = "Success", limits = c(0, 1), begin = 0, end = 0.85) +
labs(x = "Defining Functions", y = "Elemental Architectures") +
ggtitle("Partial Success")+
theme_minimal() +
scale_y_discrete(limits = rev(levels(dat.long$Elemental.Architectures))) +
theme(
axis.title.x = element_text(vjust = -1), # Move x axis label
axis.title.y = element_text(vjust = 1),  # Adjust y axis label position if needed
axis.text.x = element_text(vjust = 0.5, hjust = 0.5), # Rotate x axis labels
axis.text.x.top = element_text(vjust = 0.5, hjust = 0.5), # Rotate top x axis labels
axis.title.x.top = element_text(vjust = 2), # Adjust top x axis title position
axis.title.y.right = element_text(vjust = 1) # Adjust right y axis title position if needed
) +
scale_x_discrete(position = "top") # Move x axis to the top
### calculations for function and elem arch means ###
addition_mean <- mean(dat$addition) #0.55
View(dat)
# read in partial matrix (condensed version) for 5 cohort set
small <- read.csv("../results/partial.matrix_mean.csv")
# read in partial matrix (condensed version) for 15 cohort set
large <- read.csv("../results/additional.cohorts.results/15cohorts/jd_partial_matrix_means.csv")
ae <- as.matrix(small[4,3:6])
ae_meansmall <- mean(ae) #0.43
de <- as.matrix(small[5,3:6])
de_meansmall <- mean(de) #0.18
ee <- as.matrix(small[6,3:6])
ee_meansmall <- mean(ee) #0.51
# read in partial matrix (condensed version) for 5 cohort set
small <- read.csv("../results/partial.matrix_mean.csv")
# read in partial matrix (condensed version) for 15 cohort set
large <- read.csv("../results/additional.cohorts.results/15cohorts/jd_partial_matrix_means.csv")
# LARGE COHORT SET - 15 cohorts - ELEM ARCHS
aa <- as.matrix(large[1,3:6])
aa_meanlarge <- mean(aa) #0.94
ad <- as.matrix(large[2,3:6])
ad_meanlarge <- mean(ad) #0.395
dd <- as.matrix(large[3,3:6])
dd_meanlarge <- mean(dd) #0.74
ae <- as.matrix(large[4,3:6])
ae_meanlarge <- mean(ae) #0.43
de <- as.matrix(large[5,3:6])
de_meanlarge <- mean(de) #0.18
ee <- as.matrix(large[6,3:6])
ee_meanlarge <- mean(ee) #0.
library(SAGA2)
help(SAGA2)
help("SAGA2")
help("SAGA"
help(saga2)
